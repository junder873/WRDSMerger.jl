var documenterSearchIndex = {"docs":
[{"location":"basic_linking/#Basics-of-Linking-Identifiers","page":"Linking Basics","title":"Basics of Linking Identifiers","text":"A core part of this package is to provide a simple and consistent interface for linking different identifiers in WRDS. One of the primary goals is to reduce the overhead of remembering how exactly to link one dataset to another.","category":"section"},{"location":"basic_linking/#Downloading-and-Saving-Data","page":"Linking Basics","title":"Downloading and Saving Data","text":"To do so, first download the necessary data from WRDS. This package provides download functions to do so (see Linking Download Functions), which are automatically called by respective generating functions (see Generating LinkPair Functions). The generating functions take in a DataFrame (which expects certain column names) and creates the necessary functions between its identifiers. Finally, calling create_all_links() will create the remaining links that the tables do not provide.\n\nTo provide an example:\n\njulia> conn = LibPQ.Connection(\"host=wrds-pgdata.wharton.upenn.edu port=9737 ...\");\njulia> generate_crsp_links(conn) # downloads the data, creates links between\n# Permno <-> Permco, Permno <-> NCusip, etc.\n# and returns the data that is downloaded\n\njulia> generate_comp_crsp_links(conn) # similar to generate_crsp_links\n\njulia> create_all_links() # defines functions between NCusip <-> GVKey,\n# Ticker <-> GVKey, etc.\n\nFor CRSP V2 data, use generate_crsp_links_v2 instead of generate_crsp_links:\n\njulia> generate_crsp_links_v2(conn) # uses crsp.stocknames_v2 and crsp.dsf_v2\n\nThe generate functions return the DataFrame that is downloaded so you can save it locally (with CSV.jl, Arrow.jl, etc.) and can use again as opposed to re-downloading the data.\n\nThis package also provides a simple function that runs all of these:\n\njulia> WRDSMerger.download_all_links(conn)\n\nWhich downloads all 6 default tables and returns those 6 DataFrames. Note that if your WRDS account lacks access to one of the tables, you need to change which items are downloaded.\n\nFor example, the code I use when starting a project is:\n\ndata_dir = joinpath(path_to_saved_files)\ndfs = download_all_links(conn)\nfiles = [\n    \"crsp_links\",\n    \"crsp_comp_links\",\n    \"gvkey_cik_links\",\n    \"ibes_links\",\n    \"option_links\",\n    \"ravenpack_links\"\n]\n# I prefer Arrow.jl and feather files, replace with CSV.jl if desired\nfor (df, file) in zip(dfs, files)\n    Arrow.write(joinpath(data_dir, file * \".feather\"), df)\nend\n\nThen, whenever I reload the project:\n\nfuns=[\n    generate_crsp_links,\n    generate_comp_crsp_links,\n    generate_comp_cik_links,\n    generate_ibes_links,\n    generate_option_crsp_links,\n    generate_ravenpack_links\n]\nfor (file, f) in zip(files, funs)\n    @chain joinpath(data_dir, file * \".feather\") begin\n        Arrow.Table\n        DataFrame\n        copy\n        f\n    end\nend\ncreate_all_links()","category":"section"},{"location":"basic_linking/#Using-Local-Files-with-DuckDB","page":"Linking Basics","title":"Using Local Files with DuckDB","text":"An alternative to downloading data from WRDS and saving individual link DataFrames is to use DuckDB.jl to read local copies of WRDS tables directly. DuckDB can read Parquet, CSV, and many other file formats without loading them into memory first.\n\nSince the generate_* functions accept a database connection and table name arguments, you can point them at local files instead of WRDS tables. When using DuckDB, local file paths must be wrapped in single quotes so that DuckDB treats them as file references in the SQL query:\n\nusing DuckDB, WRDSMerger\nconn = DBInterface.connect(DuckDB.DB, \":memory:\")\n\n# For CRSP V2 with local Parquet files:\ngenerate_crsp_links_v2(conn, \"'stocknames_v2.parquet'\", \"'dsf_v2.parquet'\")\ngenerate_comp_crsp_links(conn, \"'ccmxpf_lnkhist.parquet'\")\ngenerate_comp_cik_links(conn, \"'comp_company.parquet'\")\ngenerate_ibes_links(conn, \"'ibcrsphist.parquet'\")\ngenerate_option_crsp_links(conn, \"'secnmd.parquet'\")\n# generate_ravenpack_links requires a cusip_list argument as well\ncreate_all_links()\n\nThis approach avoids the save/reload cycle entirely and is especially convenient if you maintain a personal copy of WRDS tables as Parquet files. You can also use a persistent DuckDB database file instead of :memory: if you have already loaded the data:\n\nconn = DBInterface.connect(DuckDB.DB, \"my_wrds_data.duckdb\")\ngenerate_crsp_links_v2(conn, \"crsp.stocknames_v2\", \"crsp.dsf_v2\")\n# ... etc.","category":"section"},{"location":"basic_linking/#Linking-Identifiers","page":"Linking Basics","title":"Linking Identifiers","text":"Once the initial data is downloaded and necessary functions are created, the package provides a consistent set of methods to convert one identifier to any other. This follows the pattern:\n\n(ID You Want)((ID You Have)(value), Date for conversion)\n\nFor example:\n\nGVKey(Permno(47896), Date(2020))\nNCusip(CIK(19617), Date(2020)) # works for Int or String\nCIK(Permno(47896), Date(2020))\nCIK(NCusip(\"46625H21\"), Date(2020))\n\nAs you can see, this includes cases where there is not a table providing a direct link (CIK <-> Permno, CIK <-> NCusip). This makes it easy to link the varied datasets in WRDS.\n\nThese functions can be easily used with broadcasting:\n\nGVKey.(Permno.([47896, 44206, 46703]), Date(2020))\nGVKey.(Permno.([47896, 44206, 46703]), [Date(2018), Date(2019), Date(2020)])\n\nOr with other packages such as DataFramesMeta.jl:\n\n@chain df begin\n    @rtransform(:gvkey = GVKey(Permno(:permno), :date))\nend\n\nAll of the identifiers that this package provides by default are seen in Identifier Types. This is expandable as discussed in Adding New Identifiers.","category":"section"},{"location":"basic_linking/#Generating-LinkPair-Functions","page":"Linking Basics","title":"Generating LinkPair Functions","text":"This section describes the default functions that exist to generate the necessary links.","category":"section"},{"location":"basic_linking/#WRDSMerger.generate_crsp_links","page":"Linking Basics","title":"WRDSMerger.generate_crsp_links","text":"generate_crsp_links(\n    conn;\n    main_table=default_tables[\"crsp_stocknames\"],\n    stockfile=default_tables[\"crsp_stock_data\"]\n)\n\ngenerate_crsp_links(df::AbstractDataFrame)\n\nGenerates the methods linking  Permno, Permco, HdrCusip, NCusip, HdrCusip6, NCusip6 and Ticker to each other. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\nThe file used (crsp.stocknames), does not have a clear way to differentiate different priorities. The most common way is to calculate the market cap of any conflicting securities to determine the best option. The ideal is the market cap on the relevant day, but since this needs a static value, the default download is to average the market cap over the relevant period.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_crsp_links_v2","page":"Linking Basics","title":"WRDSMerger.generate_crsp_links_v2","text":"generate_crsp_links_v2(\n    conn,\n    main_table=default_tables[\"crsp_stocknames_v2\"],\n    stockfile=default_tables[\"crsp_stock_data_v2\"]\n)\n\ngenerate_crsp_links_v2(df::AbstractDataFrame)\n\nGenerates the methods linking Permno, Permco, Cusip, NCusip, Cusip6, NCusip6 and Ticker to each other. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\nSomewhat confusingly, the v2 files have HdrCusip and Cusip, but the Cusip is equivalent to the old NCusip and the HdrCusip is equivalent to the old Cusip.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_comp_crsp_links","page":"Linking Basics","title":"WRDSMerger.generate_comp_crsp_links","text":"generate_comp_crsp_links(\n    conn,\n    main_table=default_tables[\"crsp_a_ccm_ccmxpf_lnkhist\"]\n)\n\ngenerate_comp_crsp_links(df::AbstractDataFrame)\n\nGenerates the methods linking GVKey and Permno/Permco based on  the CRSP/Compustat merged annual file link history (crsp_a_ccm.ccmxpf_lnkhist). If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_comp_cik_links","page":"Linking Basics","title":"WRDSMerger.generate_comp_cik_links","text":"generate_comp_cik_links(\n    conn;\n    main_table=default_tables[\"comp_company\"]\n)\n\ngenerate_comp_cik_links(df::AbstractDataFrame)\n\nGenerates the methods linking GVKey and CIK based on  the Compustat company name file (comp.company). GVKey and CIK do not have any date conditions, so this download is relatively simple. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_ibes_links","page":"Linking Basics","title":"WRDSMerger.generate_ibes_links","text":"generate_ibes_links(\n    conn,\n    main_table=default_tables[\"wrdsapps_ibcrsphist\"]\n)\n\ngenerate_ibes_links(df::AbstractDataFrame)\n\nGenerates the methods between IbesTicker and Permno/NCusip based on a standard WRDS file. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_option_crsp_links","page":"Linking Basics","title":"WRDSMerger.generate_option_crsp_links","text":"generate_option_crsp_links(\n    conn;\n    main_table=default_tables[\"optionm_all_secnmd\"]\n)\n\ngenerate_option_crsp_links(df::AbstractDataFrame)\n\nGenerates the methods linking SecID and NCusip based on  the option names file (optionm_all.secnmd). This file only provides an \"effective date\", so it is assumed that once the next \"effective date\"  occurs, the link is no longer valid. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"basic_linking/#WRDSMerger.generate_ravenpack_links","page":"Linking Basics","title":"WRDSMerger.generate_ravenpack_links","text":"generate_ravenpack_links(\n    conn,\n    main_table=default_tables[\"ravenpack_common_rp_entity_mapping\"],\n    cusip_list=default_tables[\"crsp.stocknames\"]\n)\n\ngenerate_ravenpack_links(df::AbstractDataFrame)\n\nGenerates the methods linking RPEntity and NCusip6 based on  the RavenPack Entity Mapping file (ravenpack_common.rp_entity_mapping). This file is very messy, so the automatic options make several assumptions and filters. First, when downloading the data, it filters any NCusip in the RavenPack file that is not in the crsp.stocknames file. Second, for each RPEntity, if the end date is missing, it assumes the next start date is the appropriate end date for the link. If a database connection is provided, then it will download the table, otherwise, it can use a provided DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#Linking-Internals","page":"Internals","title":"Linking Internals","text":"","category":"section"},{"location":"linking_internals/#Underlying-Methodology-of-convert_identifier","page":"Internals","title":"Underlying Methodology of convert_identifier","text":"","category":"section"},{"location":"linking_internals/#LinkPairs","page":"Internals","title":"LinkPairs","text":"This packages primary storage method for links is an AbstractLinkPair, which is typically a LinkPair:\n\nConceptually, a LinkPair provides a one direction link between T1 -> T2. These are typically stored in a dictionary for quick lookup:\n\nDict{T1, Vector{LinkPair{T1, T2}}}()\n\nand this package adds a function to Dict to convert an abstract vector of LinkPairs to such a dictionary:","category":"section"},{"location":"linking_internals/#Defining-New-AbstractLinkPairs","page":"Internals","title":"Defining New AbstractLinkPairs","text":"While this package currently makes use of LinkPair, it might be easier for other identifiers to define a more complex AbstractLinkPair. A key component of an AbstractLinkPair is being able to compare when one link should be used as opposed to another, which this package refers to as priority. In some cases, there might be multiple values that determine a priority. For example, the link between GVKey <-> Permno has two columns, depending on the direction (e.g., going from Permno -> GVKey, \"LC\" > \"LU\" > \"LS\"...). This package converts these into a single number with decimals (\"LC\" = 8, \"LU\" = 7... and the other column, \"P\" = 0.3, \"C\" = 0.2 ..., added together). This is switched when defining the link between GVKey -> Permno (\"LC\" = 0.8, \"P\" = 3). An alternative way to define this would be to create a separate AbstractLinkPair type that would avoid adding and, perhaps, be clearer on methodology. For example, something like:\n\nstruct CrspCompLinkPair{T1<:AbstractIdentifier, T2<:AbstractIdentifier} <: AbstractLinkPair{T1, T2}\n    parent::T1\n    child::T2\n    dt1::Date# first date valid\n    dt2::Date# last date valid\n    comp_crsp_priority::Int\n    crsp_comp_priority::Int\n    function CrspCompLinkPair(\n        t1::T1,\n        t2::T2,\n        dt1::Date,\n        dt2::Date,\n        linktype::AbstractString,\n        linkprim::AbstractString\n    ) where {T1, T2}\n        comp_crsp_priority = if linkprim == \"P\"\n            3\n        elseif linkprim == \"C\"\n            2\n        elseif linkprim == \"J\"\n            1\n        end\n        crsp_comp_priority = if linktype == \"LC\"\n            8\n        elseif linktype == \"LU\"\n            7\n        elseif linktype == \"LS\"\n            6\n        elseif linktype == \"LX\"\n            5\n        elseif linktype == \"LD\"\n            4\n        elseif linktype == \"LN\"\n            3\n        elseif linktype == \"NR\"\n            2\n        elseif linktype == \"NU\"\n            1\n        end\n        new{T1, T2}(t1, t2, dt1, dt2, comp_crsp_priority, crsp_comp_priority)\n    end\nend\n\nWhile most of the default functions for AbstractLinkPair would work with this new type (parentID, childID, min_date, max_date, Base.in), the one that does not is priority, which determines which AbstractLinkPair is preferable. Since the direction of the link matters, two new priority functions are required:\n\nfunction WRDSMerger.priority(data::CrspCompLinkPair{GVKey, T2}) where {T2<:AbstractIdentifier}\n    data.comp_crsp_priority + data.crsp_comp_priority / 10\nend\n\nfunction WRDSMerger.priority(data::CrspCompLinkPair{T1, GVKey}) where {T1<:AbstractIdentifier}\n    data.crsp_comp_priority + data.comp_crsp_priority / 10\nend\n\nWhile this case is not used by default in this package, following similar methodology could allow for more complex priority structures.","category":"section"},{"location":"linking_internals/#Linking-Download-Functions","page":"Internals","title":"Linking Download Functions","text":"","category":"section"},{"location":"linking_internals/#Changing-The-Priority-for-Permno","page":"Internals","title":"Changing The Priority for Permno","text":"A single company can have many securities, therefore, there might be multiple options when linking these items. For example, a single GVKey or Permco will match to multiple Permnos. In some tables in WRDS (such as in the case of GVKey <-> Permno), there are explicit primary identifier markers provided, improving the match. In others, there are not (as in Permco <-> Permno). This is a particular problem for Permno since this package prioritizes matches through Permno (as discussed in Supremacy of Permno).\n\nThe most common method to resolve these matches is to find the Permno that has the largest market capitalization on the day of the match since that should be the primary identifier. This is difficult to do in a package like this where the values are, ideally, predetermined. Therefore, the default behavior is to average the market capitalization over the period of the link and choose the higher average market capitalization. This behavior is convenient (requiring only a single SQL download), but potentially inconsistent with the end goal. Specifically, if one link has a lower average market capitalization (perhaps due to a long time window where the value was lower) than another link, this package might pick the Permno with a smaller market capitalization on the day of the match.\n\nThis is a proposed alternative that makes use of the AbnormalReturns.jl package to provide a quick lookup of the market capitalization just before the link:\n\nFirst, stock price data is required:\n\nusing WRDSMerger, DataFramesMeta, AbnormalReturns\ndf = raw_sql(wrds_conn, \"SELECT permno, date, abs(prc) * shrout AS mkt_cap FROM crsp.dsf\")\n@rtransform!(df, :mkt_cap = coalesce(:mkt_cap, 0.0))\n\nnote: Note\nIt is recommended to provide some filter on the WRDS download as the crsp.dsf file has over 100 million rows, downloading this data takes a lot of ram, peaking at ~20 GB. Most obviously, selecting dates beyond a certain point helps a lot.\n\nAbnormalReturns needs a market calendar, instead of downloading something, just reuse the dates from df and load that into a MarketData object:\n\nmkt_data = MarketData(\n    @by(df, :date, :full_mkt = mean(:mkt_cap)),\n    df\n)\n\nThen we need to redefine how WRDSMerger goes about choosing between two links when the outcome is a Permno. It is also important to do some error checking since AbnormalReturns does not accept cases when the date is out of the range available or the Permno is not in the dataset. WRDSMerger determines priority uses the is_higher_priority function, which checks the priority of two AbstractLinkPairs and compares them. Therefore, changing the priority function slightly when the outcome is a Permno will create the necessary changes:\n\nfunction WRDSMerger.priority(\n    data::AbstractLinkPair{T1, Permno},\n    dt::Date;\n    mkt_data=mkt_data # need the market data defined above\n) where {T1}\n    if dt < AbnormalReturns.cal_dt_min(mkt_data.calendar) || dt > AbnormalReturns.cal_dt_min(mkt_data.calendar)\n        return 0.0\n    end\n    if dt > AbnormalReturns.cal_dt_min(mkt_data.calendar)\n        # typically, the market cap on the day before is checked\n        # but it is also important to avoid going outside the calendar\n        # range\n        dt = BusinessDays.advancebdays(mkt_data.calendar, dt, -1)\n    end\n    permno_val = WRDSMerger.childID(data)\n    if haskey(mkt_data.firmdata, permno_val)\n        coalesce(\n            mkt_data[permno_val, dt, :mkt_cap], # returns value or missing\n            0.0\n        )\n    else\n        0.0\n    end\nend\n\nThis method is obviously slower than the default setup, but would provide the market capitalization on the day before the match.\n\nThis is not the default in this package since many of these operations are costly, particularly downloading the data.","category":"section"},{"location":"linking_internals/#Adding-New-Identifiers","page":"Internals","title":"Adding New Identifiers","text":"There are likely other identifiers in WRDS that are not included by default in this package, making it necessary to define a new identifier. This is quite easy. First, define a new type:\n\nstruct IdentiferName <: FirmIdentifier\n    val::String\n    IdentifierName(x::AbstractString) = new(x)\nend\n\nWRDSMerger.value(x::IdentifierName) = x.val\n\nReplacing FirmIdentifier with SecurityIdentifier if necessary and choosing between String or Int or some other type.\n\nNext, provide the information that links this new identifier to some other identifier in the package. This is done by calling new_link_method:\n\nSpecifically the method with a vector of AbstractLinkPairs or the dictionary version. Therefore, you need to create a vector of these links, I will assume use of the LinkPair type, but this can be adjusted as discussed in Defining New AbstractLinkPairs. A LinkPair requires 5 elements: the ID it is coming from (parent ID), the ID it is going to (child ID), a start and end date, and a priority (though the start and end date and priority have defaults). Therefore, it is easiest if you create a DataFrame that has similar data (i.e., a column of parent ID, child ID, start date, end date, priority). This package then has a function that allows you to create the bi-directional links required, create_link_pair:\n\nSince this returns a tuple of dictionaries, each needs to be passed to new_link_method to create the bidirectional links. Then, to create links beyond just T1 <-> T2, call create_all_links().","category":"section"},{"location":"linking_internals/#Core-Functions","page":"Internals","title":"Core Functions","text":"","category":"section"},{"location":"linking_internals/#Other-Functions","page":"Internals","title":"Other Functions","text":"","category":"section"},{"location":"linking_internals/#WRDSMerger.convert_identifier","page":"Internals","title":"WRDSMerger.convert_identifier","text":"convert_identifier(::Type{ID}, x::T1, dt::Date; vargs...) where {ID<:AbstractIdentifier, T1<:AbstractIdentifier}\n\nconvert_identifier(\n    ::Type{ID},\n    x::T1,\n    dt::Date,\n    data::Dict{T1, Vector{<:AbstractLinkPair{T1, ID}}}=data;\n    vargs...\n) where {ID<:AbstractIdentifier, T1<:AbstractIdentifier}\n\nConverts an identifier (T1) to a different identifier (ID). In its most generic form, this throws a MethodError implying there is not a function that exists to directly link T1 -> ID.\n\nCalling new_link_method calls a macro to create different versions of convert_identifier to provide links between identifiers. If these are direct links (which means there is a  AbstractLinkPair that links the two identifiers, such as Permno -> Permco or Permno -> NCusip), then this provides a one step method to link these two identifiers.\n\nFor other identifiers, there is not a link table that provides a direct link (such as SecID -> GVKey). In those cases, new_link_method will find a path between the two (in the case of SecID -> GVKey, SecID -> NCusip -> Permno -> GVKey). Each case of convert_identifier only does 1 step in the process, so convert_identifier(GVKey, SecID(1), today()) would call convert_identifier(Permno, SecID(1), today()).\n\nnote: Note\nThere are two slightly different behaviors for the direct links of convert_identifier. When linking a SecurityIdentifier -> FirmIdentifier, the function might retry if a link is not found with the parent identifier of the security. For example, when trying to link NCusip -> GVKey, the default behavior is to try NCusip -> Permno -> GVKey. However, suppose there is not a matching NCusip -> Permno, the function will try again with NCusip6 -> Permno. The logic is that it should not matter if the Permno does not perfectly match the NCusip if the end goal is  to find a relevant GVKey. This behavior can be disabled by using allow_parent_firm=false.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.AbstractLinkPair","page":"Internals","title":"WRDSMerger.AbstractLinkPair","text":"AbstractLinkPair{T1<:AbstractIdentifier, T2<:AbstractIdentifier}\n\nAbstract supertype for all link pairs. A link pair represents a directional relationship from identifier type T1 to T2 over a date range with an associated priority. See LinkPair for the concrete default implementation and Defining New AbstractLinkPairs for how to create custom subtypes.\n\nRequired interface for subtypes: parentID, childID, min_date, max_date, priority.\n\n\n\n\n\n","category":"type"},{"location":"linking_internals/#WRDSMerger.LinkPair","page":"Internals","title":"WRDSMerger.LinkPair","text":"function LinkPair(\n    parent::T1,\n    child::T2,\n    dt1::Union{Missing, Date, String}=Date(0, 1, 1),\n    dt2::Union{Missing, Date, String}=Date(9999, 12, 31),\n    priority::Real=0.0\n) where {T1<:AbstractIdentifier, T2<:AbstractIdentifier}\n\nLinkPair is the basic structure that provides a link between two identifiers. These are defined as a single direction link (T1 -> T2) that is valid between a specific date range (inclusive) and has a given priority (higher is better). Priority is useful if there are overlapping T1 -> T2 items. For example, a FirmIdentifier likely has multiple SecurityIdentifiers that relate to it. One common way to pick between different SecurityIdentifiers is to pick the one with the larger market cap as the primary.\n\nIf the source data provides priority as something other than a number (such as a String indicating priority), convert it to a numeric value before constructing the LinkPair. See gvkey_crsp_priority and crsp_gvkey_priority for examples of functions that convert CRSP/Compustat link priority strings into numeric priorities.\n\n\n\n\n\n","category":"type"},{"location":"linking_internals/#Base.Dict","page":"Internals","title":"Base.Dict","text":"Dict(data::AbstractVector{L}) where {T1, T2, L<:AbstractLinkPair{T1, T2}}\n\nConverts a vector of AbstractLinkPairs to a dictionary where each T1 is a key in the dictionary and the values are vectors of L. It also checks whether those vectors ever have overlapping inconsistent priorities.\n\n\n\n\n\n","category":"type"},{"location":"linking_internals/#WRDSMerger.download_crsp_links","page":"Internals","title":"WRDSMerger.download_crsp_links","text":"download_crsp_links(conn, main_table=\"crsp.stocknames\", stockfile=\"crsp.dsf\")\n\nRuns the following SQL code (tables are changeable by setting the main_table and stockfile keyword arguments):\n\nselect a.*, b.mkt_cap from crsp.stocknames a\n        left join (\n            select s.permno, s.namedt, s.nameenddt, avg(d.mkt_cap) as mkt_cap from crsp.stocknames s\n                inner join (select permno, date, abs(prc) * shrout as mkt_cap from crsp.dsf) as d\n                on s.permno = d.permno and s.namedt <= d.date and s.nameenddt >= d.date\n            group by s.permno, s.namedt, s.nameenddt\n            ) b\n            on a.permno = b.permno and a.namedt = b.namedt and a.nameenddt = b.nameenddt\n\nand returns a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_crsp_links_v2","page":"Internals","title":"WRDSMerger.download_crsp_links_v2","text":"download_crsp_links_v2(conn, main_table=\"crsp.stocknames_v2\", stockfile=\"crsp.dsf_v2\")\n\nCRSP V2 equivalent of download_crsp_links. Uses dlycap (daily market cap) instead of calculating abs(prc) * shrout, and dlycaldt instead of date.\n\nRuns the following SQL code (tables are changeable by setting the main_table and stockfile arguments):\n\nselect a.*, b.mkt_cap from crsp.stocknames_v2 a\n        left join (\n            select s.permno, s.namedt, s.nameenddt, avg(d.dlycap) as mkt_cap from crsp.stocknames_v2 s\n                inner join (select permno, dlycaldt, dlycap from crsp.dsf_v2) as d\n                on s.permno = d.permno and s.namedt <= d.dlycaldt and s.nameenddt >= d.dlycaldt\n            group by s.permno, s.namedt, s.nameenddt\n            ) b\n            on a.permno = b.permno and a.namedt = b.namedt and a.nameenddt = b.nameenddt\n\nand returns a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_comp_crsp_links","page":"Internals","title":"WRDSMerger.download_comp_crsp_links","text":"download_comp_crsp_links(conn, main_table=\"crsp_a_ccm.ccmxpf_linkhist\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM crsp_a_ccm.ccmxpf_linkhist\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_comp_cik_links","page":"Internals","title":"WRDSMerger.download_comp_cik_links","text":"download_comp_cik_links(conn, main_table=\"comp.company\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM comp.company\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_ibes_links","page":"Internals","title":"WRDSMerger.download_ibes_links","text":"download_ibes_links(conn, main_table=\"wrdsapps.ibcrsphist\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM wrdsapps.ibcrsphist\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_option_crsp_links","page":"Internals","title":"WRDSMerger.download_option_crsp_links","text":"download_option_crsp_links(conn, main_table=\"optionm_all.secnmd\")\n\nRuns the following SQL code (table is changeable by setting the main_table keyword argument):\n\nSELECT * FROM optionm_all.secnmd\n\nand returns the resulting DataFrame\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_ravenpack_links","page":"Internals","title":"WRDSMerger.download_ravenpack_links","text":"download_ravenpack_links(conn, main_table=\"ravenpack.rp_entity_mapping\", cusip_list=\"crsp.stocknames\")\n\nRuns the following SQL code (tables are changeable by setting the main_table and cusip_list keyword arguments):\n\nSELECT rp_entity_id, data_value as ncusip, range_start, range_end FROM ravenpack.rp_entity_mapping as a\n            inner join (select distinct ncusip from crsp.stocknames) as b\n            on left(a.data_value, 8) = b.ncusip\n\nand returns a DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.new_link_method","page":"Internals","title":"WRDSMerger.new_link_method","text":"new_link_method(data::Vector{L}) where {L<:AbstractLinkPair}\n\nnew_link_method(data::Dict{T1, Vector{L}}) where {T1, ID, L<:AbstractLinkPair{T1, ID}}\n\nfunction new_link_method(\n    ::Type{T1},\n    ::Type{ID};\n    current_links = all_pairs(AbstractIdentifier, AbstractIdentifier)\n) where {ID<:AbstractIdentifier, T1<:AbstractIdentifier}\n\nCreates a new convert_identifier method to link T1 -> ID. See detailed notes under convert_identifier. If a vector of AbstractLinkPair or a dictionary is passed, this creates a direct link method, while passing two types will attempt to find a path between the two identifiers and define the appropriate function.\n\nWhen a direct link is created (via a vector or dictionary), this also defines an identifier_data method for the corresponding (ID, T1) pair, providing access to the underlying link dictionary.\n\nnote: Note\nall_pairs is a relatively slow function, needing to repeatedly check what methods are available. Therefore, if needing to create many new methods, it is best to run all_pairs once and pass that for each new T1 -> ID that needs to be created.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.create_link_pair","page":"Internals","title":"WRDSMerger.create_link_pair","text":"function create_link_pair(\n    ::Type{LP},\n    ::Type{T1},\n    ::Type{T2},\n    df::DataFrame,\n    sym1::Symbol,\n    sym2::Symbol,\n    dt1::Union{Symbol, Missing}=missing,\n    dt2::Union{Symbol, Missing}=missing,\n    priority_sym::Union{Symbol, Missing}=missing,\n    priority_sym2::Union{Symbol, Missing}=missing\n) where {T1<:AbstractIdentifier, T2<:AbstractIdentifier, LP<:AbstractLinkPair}\n\nGeneric function that creates an AbstractLinkPair based on the types and a DataFrame. sym1 and sym2 are the column names in df whose values will be converted to types T1 and T2, respectively. dt1 and dt2 are optional column names for the start and end dates of each link. priority_sym is an optional column name used as the priority when building links from T1 to T2, and priority_sym2 is an optional separate priority column for the reverse (T2 to T1) direction; when priority_sym2 is missing, priority_sym is used for both directions, and when both are missing a default priority of 0.0 is used.\n\nThe function selects only the relevant columns, drops rows where sym1 or sym2 are missing, and returns a tuple of two dictionaries: (Dict{T1, LP{T1, T2}}, Dict{T2, LP{T2, T1}}) which is easily passed to new_link_method.\n\nExample\n\ncreate_link_pair(\n    LinkPair,\n    Permno,\n    NCusip,\n    df,\n    :permno,\n    :ncusip,\n    :namedt,\n    :nameenddt,\n    :priority\n)\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.create_all_links","page":"Internals","title":"WRDSMerger.create_all_links","text":"create_all_links()\n\nCreate indirect links between all identifier types that do not yet have a direct link method. This should be called after all generate_* functions have been run. It finds all missing identifier pairs and creates linking methods that route through intermediate identifiers (preferring paths through Permno, see Supremacy of Permno).\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.download_all_links","page":"Internals","title":"WRDSMerger.download_all_links","text":"download_all_links(conn, funs=[...], save_dfs=true)\n\nConvenience function that calls each function in funs (passing conn) and then calls create_all_links. If save_dfs=true (default), returns a vector of the DataFrames produced by each function. The default funs are: generate_crsp_links, generate_comp_crsp_links, generate_comp_cik_links, generate_ibes_links, generate_option_crsp_links, generate_ravenpack_links.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.choose_best_match","page":"Internals","title":"WRDSMerger.choose_best_match","text":"function choose_best_match(\n    data::AbstractVector{L},\n    dt::Date;\n    allow_inexact_date=true,\n    args...\n) where {L<:AbstractLinkPair}\n\nPicks the best identifier based on the vector of links provided.\n\nArgs\n\nallow_inexact_date=true: If true, and the length of the supplied vector is 1, then is will return that value even if the supplied date does not fit within the link.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.check_priority_errors","page":"Internals","title":"WRDSMerger.check_priority_errors","text":"This function tests whether there are any dates that are in multiple AbstractLinkPairs and those links have equivalent priority. If this function returns true, then there is at least a date where there is no distinction between two links. The way choose_best_match works, the first in the vector will be chosen.\n\nThe algorithm uses a sweep-line approach: intervals are sorted by start date to efficiently find overlapping pairs. When an overlap between two links with different children is found, a representative date is checked against all active links to determine whether a higher-priority link resolves the tie. This avoids false positives where two low-priority links tie but a third higher-priority link takes precedence.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.is_higher_priority","page":"Internals","title":"WRDSMerger.is_higher_priority","text":"is_higher_priority(\n    data1::AbstractLinkPair{T1, T2},\n    data2::AbstractLinkPair{T1, T2},\n    args...\n) where {T1, T2}\n\nDetermines whether data1 has higher priority than data2. args... are automatically passed to the priorityfunction, which can then deal with special circumstances (currently passed as the date of the match). However, none of the default settings use this.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.value","page":"Internals","title":"WRDSMerger.value","text":"value(x::AbstractIdentifier)\n\nConverts an identifier into a common Julia type (typically Int or String).\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.all_pairs","page":"Internals","title":"WRDSMerger.all_pairs","text":"all_pairs(\n    a::Type{<:AbstractIdentifier},\n    b::Type{<:AbstractIdentifier}=a;\n    out = Vector{Tuple{DataType, DataType}}(),\n    test_fun = base_method_exists\n)\n\nReturns a vector of (T1, T2) tuples representing every concrete identifier pair for which test_fun(T1, T2) returns true. Both a and b are expanded to their concrete subtypes (via InteractiveUtils.subtypes) before testing, and self-pairs (T1 == T2) are skipped.\n\nBy default, test_fun is base_method_exists, which checks whether an identifier_data method exists for the pair — i.e., whether a direct link table has been loaded. This makes all_pairs useful for discovering which direct links are currently available.\n\nnote: Note\nall_pairs can be slow because it must inspect methods for every combination of concrete subtypes. When creating many indirect links with new_link_method, call all_pairs once and pass the result via the current_links keyword to avoid repeated work.\n\nExamples\n\n# All direct links currently loaded:\nall_pairs(AbstractIdentifier, AbstractIdentifier)\n\n# Check which pairs are still missing a convert_identifier method:\nall_pairs(AbstractIdentifier, AbstractIdentifier; test_fun=method_is_missing)\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.identifier_data","page":"Internals","title":"WRDSMerger.identifier_data","text":"identifier_data(::Type{ID}, ::Type{T1}) where {ID<:AbstractIdentifier, T1<:AbstractIdentifier}\n\nReturns the underlying Dict{T1, Vector{<:AbstractLinkPair{T1, ID}}} that maps source identifiers of type T1 to their link records targeting type ID.\n\nThis function is automatically defined by new_link_method whenever a direct link (i.e., one backed by an AbstractLinkPair table) is created. It can be useful for inspecting the raw link data or for advanced workflows such as serializing the dictionary for faster future loading.\n\nIf no direct link data has been loaded for the requested pair, a MethodError will be thrown.\n\nExamples\n\n# After links have been created:\ndata = identifier_data(GVKey, Permno)\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.crsp_gvkey_priority","page":"Internals","title":"WRDSMerger.crsp_gvkey_priority","text":"crsp_gvkey_priority(linkprim::AbstractString, linktype::AbstractString) -> Float64\n\nConverts CRSP/Compustat link descriptor strings into a numeric priority for links going from a CRSP identifier (Permno or Permco) to GVKey. Higher values indicate a stronger link.\n\nThe linktype flag (LC > LU > LS > LX > LD > LN > NR > NU) receives the larger weight, reflecting that the link quality matters most when starting from a security identifier. linkprim (P > C > J) serves as a tiebreaker.\n\nSee also gvkey_crsp_priority for the reverse direction.\n\n\n\n\n\n","category":"function"},{"location":"linking_internals/#WRDSMerger.gvkey_crsp_priority","page":"Internals","title":"WRDSMerger.gvkey_crsp_priority","text":"gvkey_crsp_priority(linkprim::AbstractString, linktype::AbstractString) -> Float64\n\nConverts CRSP/Compustat link descriptor strings into a numeric priority for links going from GVKey to a CRSP identifier (Permno or Permco). Higher values indicate a stronger link.\n\nThe linkprim flag (P > C > J) receives the larger weight, reflecting that the primary security match matters most when starting from a firm identifier. linktype (LC > LU > LS > LX > LD > LN > NR > NU) serves as a tiebreaker.\n\nSee also crsp_gvkey_priority for the reverse direction.\n\n\n\n\n\n","category":"function"},{"location":"linking_identifiers/#Identifier-Types","page":"Identifier Types","title":"Identifier Types","text":"This page lists all identifier types provided by default. Identifiers are thin wrappers around String or Int values that carry type information, enabling the linking system to dispatch to the correct conversion method.\n\nThere are two categories:\n\nFirm identifiers (FirmIdentifier): identify a company (e.g., GVKey, CIK, Permco)\nSecurity identifiers (SecurityIdentifier): identify a specific security (e.g., Permno, Cusip, Ticker)\n\nSome security identifiers have a \"parent\" firm identifier. For example, NCusip (8-character CUSIP) has parent NCusip6 (6-character CUSIP). This parent relationship is used for fallback matching — see Parent Firms in Default Behavior.\n\nPages = [\"linking_identifiers.md\"]","category":"section"},{"location":"linking_identifiers/#Firm-Identifiers","page":"Identifier Types","title":"Firm Identifiers","text":"Firm identifiers represent a company across all of its securities.","category":"section"},{"location":"linking_identifiers/#Security-Identifiers","page":"Identifier Types","title":"Security Identifiers","text":"Security identifiers represent a specific stock, bond, or other instrument.","category":"section"},{"location":"linking_identifiers/#WRDSMerger.AbstractIdentifier","page":"Identifier Types","title":"WRDSMerger.AbstractIdentifier","text":"Supertype for all Firm Identifiers\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.FirmIdentifier","page":"Identifier Types","title":"WRDSMerger.FirmIdentifier","text":"A FirmIdentifier specifies a specific firm over a given date range and is opposed to a SecurityIdentifier. In a standard database, a single FirmIdentifier can have multiple SecurityIdentifiers but a SecurityIdentifier should only have one FirmIdentifier.\n\nExamples include GVKey, Permco and Cusip6.\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.GVKey","page":"Identifier Types","title":"WRDSMerger.GVKey","text":"GVKey <: FirmIdentifier\n\nGVKey(s::Union{<:Real, <:AbstractString})::GVKey\n\nGVKey(x::AbstractIdentifier, d::Date)::String\n\nGVKey is the primary identifier in the Compustat universe It only contains numeric values, though is often represented as a string with 6 digits, therefore, it is stored as a String.\n\nExample\n\njulia> GVKey(2968) # GVKey for Chase\nGVKey(\"002968\")\n\njulia> GVKey(\"002968\")\nGVKey(\"002968\")\n\njulia> GVKey(Permno(47896), Date(2020))\n\"002968\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.CIK","page":"Identifier Types","title":"WRDSMerger.CIK","text":"CIK <: FirmIdentifier\n\nCIK(s::Union{<:Real, <:AbstractString})::CIK\n\nCIK(x::AbstractIdentifier, d::Date)::String\n\nCIK is a common identifier outside of WRDS It only contains numeric values, though is often represented as a string with 10 digits, therefore, it is stored as a String.\n\nExample\n\njulia> CIK(19617) # CIK for Chase\nCIK(\"0000019617\")\n\njulia> CIK(\"0000019617\")\nCIK(\"0000019617\")\n\njulia> CIK(GVKey(2968), Date(2020))\n\"0000019617\"\n\njulia> CIK(GVKey(2968)) # Date for GVKey <-> CIK is unnecessary\n\"0000019617\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Permco","page":"Identifier Types","title":"WRDSMerger.Permco","text":"Permco <: FirmIdentifier\n\nPermco(x::Real)::Permco\n\nPermco(x::AbstractIdentifier, d::Date)::Int\n\nPermco is the primary firm identifier in the CRSP universe.\n\nExample\n\njulia> Permco(20436) # Permco for Chase\nPermco(20436)\n\njulia> Permco(NCusip6(\"46625H\"), Date(2020))\n20436\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Cusip6","page":"Identifier Types","title":"WRDSMerger.Cusip6","text":"Cusip6 <: FirmIdentifier\n\nCusip6(s::AbstractString)::Cusip6\n\nCusip6(x::Cusip)::Cusip6\n\nCusip6(x::AbstractIdentifier, d::Date)::String\n\nCusip6 is the firm identifier component of Cusip. It can contain numbers or letters (with a maximum length of 6 characters).\n\nnote: Note\nCusip6 is a parameterized type: NCusip6 = Cusip6{:historical} and HdrCusip6 = Cusip6{:current}. Calling Cusip6(x) defaults to historical (NCusip6).In CRSP V1, the column cusip (first 6 chars) was the current/header value and ncusip (first 6 chars) was historical. In CRSP V2, the column cusip (first 6 chars) is historical and hdrcusip (first 6 chars) is the current value.\n\nExample\n\njulia> HdrCusip6(\"46625H\") # Cusip6 for Chase\nHdrCusip6(\"46625H\")\n\njulia> HdrCusip6(HdrCusip(\"46625H10\")) # Cusip6 is the first 6 digits of a Cusip\nHdrCusip6(\"46625H\")\n\njulia> HdrCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\nRelated to the note on the difference between Cusip6 and NCusip6:\n\njulia> HdrCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> HdrCusip6(Permno(47896), Date(1998))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(1998))\n\"16161A\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.NCusip6","page":"Identifier Types","title":"WRDSMerger.NCusip6","text":"NCusip6 <: FirmIdentifier\n\nNCusip6(s::AbstractString)::NCusip6\n\nNCusip6(x::NCusip)::NCusip6\n\nNCusip6(x::AbstractIdentifier, d::Date)::String\n\nNCusip6 is the firm identifier component of NCusip. It can contain numbers or letters (with a maximum length of 6 characters).\n\nnote: Note\nNCusip6 is from CRSP v1 where it would provide a historical view of the first 6 characters of the Cusip, while Cusip6 would provide the most recently available 6 characters.In CRSP v2, Cusip6 would represent the historical information while HdrCusip6 would represent the most recently available 6 characters.\n\nExample\n\njulia> NCusip6(\"46625H\") # NCusip6 for Chase\nNCusip6(\"46625H\")\n\njulia> NCusip6(NCusip(\"46625H10\")) # NCusip6 is the first 6 digits of a Cusip\nNCusip6(\"46625H\")\n\njulia> NCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\nRelated to the note on the difference between Cusip6 and NCusip6:\n\njulia> HdrCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> HdrCusip6(Permno(47896), Date(1998))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(1998))\n\"16161A\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.HdrCusip6","page":"Identifier Types","title":"WRDSMerger.HdrCusip6","text":"Cusip6 <: FirmIdentifier\n\nCusip6(s::AbstractString)::Cusip6\n\nCusip6(x::Cusip)::Cusip6\n\nCusip6(x::AbstractIdentifier, d::Date)::String\n\nCusip6 is the firm identifier component of Cusip. It can contain numbers or letters (with a maximum length of 6 characters).\n\nnote: Note\nCusip6 is a parameterized type: NCusip6 = Cusip6{:historical} and HdrCusip6 = Cusip6{:current}. Calling Cusip6(x) defaults to historical (NCusip6).In CRSP V1, the column cusip (first 6 chars) was the current/header value and ncusip (first 6 chars) was historical. In CRSP V2, the column cusip (first 6 chars) is historical and hdrcusip (first 6 chars) is the current value.\n\nExample\n\njulia> HdrCusip6(\"46625H\") # Cusip6 for Chase\nHdrCusip6(\"46625H\")\n\njulia> HdrCusip6(HdrCusip(\"46625H10\")) # Cusip6 is the first 6 digits of a Cusip\nHdrCusip6(\"46625H\")\n\njulia> HdrCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\nRelated to the note on the difference between Cusip6 and NCusip6:\n\njulia> HdrCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(2020))\n\"46625H\"\n\njulia> HdrCusip6(Permno(47896), Date(1998))\n\"46625H\"\n\njulia> NCusip6(Permno(47896), Date(1998))\n\"16161A\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.RPEntity","page":"Identifier Types","title":"WRDSMerger.RPEntity","text":"RPEntity <: FirmIdentifier\n\nRPEntity(x::String)::RPEntity\n\nRPEntity(x::AbstractIdentifier, d::Date)::String\n\nRPEntity is used within RavenPack to identify different entities.\n\nExample\n\njulia> RPEntity(\"619882\") # RPEntity for Chase\nRPEntity(\"619882\")\n\njulia> RPEntity(NCusip6(\"46625H\"), Date(2020))\n\"619882\"\n\njulia> NCusip6(RPEntity(\"619882\"), Date(2020))\n\"46625H\"\n\nnote: Note\nThe RavenPack links are especially messy, for example, there are two links for RPEntity -> NCusip6 from 2001-01-01 - 2001-05-31, and there is not easy way to distinguish these. This package simply returns the first value in such cases\n\njulia> RPEntity(NCusip6(\"46625H\"), Date(2001, 3))\n\"619882\"\n\njulia> RPEntity(NCusip6(\"616880\"), Date(2001, 3))\n\"619882\"\n\njulia> NCusip6(RPEntity(\"619882\"), Date(2001, 3))\n\"46625H\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.SecurityIdentifier","page":"Identifier Types","title":"WRDSMerger.SecurityIdentifier","text":"A SecurityIdentifier specifies a specific firm over a given date range and is opposed to a FirmIdentifier. In a standard database, a single FirmIdentifier can have multiple SecurityIdentifiers but a SecurityIdentifier should only have one FirmIdentifier.\n\nExamples include Permno, Cusip and Ticker.\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Permno","page":"Identifier Types","title":"WRDSMerger.Permno","text":"Permno <: SecurityIdentifier\n\nPermno(x::Real)::Permno\n\nPermno(x::AbstractIdentifier, d::Date)::Int\n\nPermno is the primary security identifier in the CRSP universe, it is also one of the most common methods of linking between databases since it is easy to find links to Cusip and Compustat (GVKey), and Cusip.\n\nExample\n\njulia> Permno(47896) # Permno for Chase\nPermno(47896)\n\njulia> Permno(NCusip6(\"46625H\"), Date(2020))\n47896\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Cusip","page":"Identifier Types","title":"WRDSMerger.Cusip","text":"Cusip <: SecurityIdentifier\n\nCusip(s::AbstractString)::Cusip\n\nCusip(issuer::AbstractString, issue::AbstractString, checksum=nothing)::Cusip\n\nCusip(x::AbstractIdentifier, d::Date)::String\n\nCusip is a common identifier within and outside of WRDS WRDS tracks older Cusips as NCusip all Cusips are made up of 3 parts, issuer (first 6 characters), issue (next 2 characters), and a checksum most databases in WRDS only use the 8 characters. If 9 digits are passed or the checksum is explicitly passed, the checksum is validated and a warning is given if it is an invalid checksum.\n\nnote: Note\nCusip is a parameterized type: NCusip = Cusip{:historical} and HdrCusip = Cusip{:current}. Calling Cusip(x) defaults to historical (NCusip).In CRSP V1, the column cusip was the current/header value and ncusip was historical. In CRSP V2, the column cusip is historical and hdrcusip is the current value. The default of Cusip(x) returning a historical identifier is consistent with the V2 convention and is generally the safer default since the inexact date matching (see choose_best_match) will still find the correct link when only one match exists.\n\nnote: Note\nCusip only stores 8 characters (not the checksum digit) and, by default, only returns those 8 characters. This means that if using a join function on a set of Cusips with 9 characters and the default output, there will be no matches. It is easiest to shorten the 9 digit Cusips to 8 digits before joining.\n\nExample\n\njulia> HdrCusip(\"46625H10\") # Cusip for Chase\nHdrCusip(\"46625H10\")\n\njulia> HdrCusip(\"46625H\", \"10\") # can also provide the parts separately\nHdrCusip(\"46625H10\")\n\njulia> HdrCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\nRelated to the note on the difference between Cusip and NCusip:\n\njulia> HdrCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> HdrCusip(Permno(47896), Date(1998))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(1998))\n\"16161A10\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.NCusip","page":"Identifier Types","title":"WRDSMerger.NCusip","text":"NCusip <: SecurityIdentifier\n    \nNCusip(s::AbstractString)::NCusip\n\nNCusip(issuer::AbstractString, issue::AbstractString, checksum=nothing)::NCusip\n\nNCusip(x::AbstractIdentifier, d::Date)::String\n\nNCusip is a type alias for Cusip{:historical}, representing the historical Cusip identifier for a security. It is a common identifier within and outside of WRDS.\n\nAll NCusips are made up of 3 parts: issuer (first 6 characters), issue (next 2 characters), and a checksum. Most databases in WRDS only use the 8 characters. If 9 digits are passed or the checksum is explicitly passed, the checksum is validated and a warning is given if it is an invalid checksum.\n\nnote: Note\nIn CRSP V1, ncusip was the column name for the historical Cusip. In CRSP V2, the plain cusip column is the historical value (and maps to NCusip), while hdrcusip is the current/header value (mapped to HdrCusip). NCusip is equivalent to calling Cusip(x) (which defaults to historical).\n\nnote: Note\nNCusip only stores 8 characters (not the checksum digit) and, by default, only returns those 8 characters. This means that if using a join function on a set of NCusips with 9 characters and the default output, there will be no matches. It is easiest to shorten the 9 digit NCusips to 8 digits before joining.\n\nExample\n\njulia> NCusip(\"46625H10\") # NCusip for Chase\nNCusip(\"46625H10\")\n\njulia> NCusip(\"46625H\", \"10\") # can also provide the parts separately\nNCusip(\"46625H10\")\n\njulia> NCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\nRelated to the note on the difference between Cusip and NCusip:\n\njulia> HdrCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> HdrCusip(Permno(47896), Date(1998))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(1998))\n\"16161A10\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.HdrCusip","page":"Identifier Types","title":"WRDSMerger.HdrCusip","text":"Cusip <: SecurityIdentifier\n\nCusip(s::AbstractString)::Cusip\n\nCusip(issuer::AbstractString, issue::AbstractString, checksum=nothing)::Cusip\n\nCusip(x::AbstractIdentifier, d::Date)::String\n\nCusip is a common identifier within and outside of WRDS WRDS tracks older Cusips as NCusip all Cusips are made up of 3 parts, issuer (first 6 characters), issue (next 2 characters), and a checksum most databases in WRDS only use the 8 characters. If 9 digits are passed or the checksum is explicitly passed, the checksum is validated and a warning is given if it is an invalid checksum.\n\nnote: Note\nCusip is a parameterized type: NCusip = Cusip{:historical} and HdrCusip = Cusip{:current}. Calling Cusip(x) defaults to historical (NCusip).In CRSP V1, the column cusip was the current/header value and ncusip was historical. In CRSP V2, the column cusip is historical and hdrcusip is the current value. The default of Cusip(x) returning a historical identifier is consistent with the V2 convention and is generally the safer default since the inexact date matching (see choose_best_match) will still find the correct link when only one match exists.\n\nnote: Note\nCusip only stores 8 characters (not the checksum digit) and, by default, only returns those 8 characters. This means that if using a join function on a set of Cusips with 9 characters and the default output, there will be no matches. It is easiest to shorten the 9 digit Cusips to 8 digits before joining.\n\nExample\n\njulia> HdrCusip(\"46625H10\") # Cusip for Chase\nHdrCusip(\"46625H10\")\n\njulia> HdrCusip(\"46625H\", \"10\") # can also provide the parts separately\nHdrCusip(\"46625H10\")\n\njulia> HdrCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\nRelated to the note on the difference between Cusip and NCusip:\n\njulia> HdrCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(2020))\n\"46625H10\"\n\njulia> HdrCusip(Permno(47896), Date(1998))\n\"46625H10\"\n\njulia> NCusip(Permno(47896), Date(1998))\n\"16161A10\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.Ticker","page":"Identifier Types","title":"WRDSMerger.Ticker","text":"Ticker <: SecurityIdentifier\n\nTicker(s::AbstractString)::Ticker\n\nTicker(x::AbstractIdentifier, d::Date)::String\n\nTicker is a stock market ticker that is often seen on the NYSE or other exchanges. It typically consists of 1-4 characters.\n\nnote: Note\nTicker should be kept distinct from IbesTicker. IbesTicker is within the IBES database and often differs from Ticker.\n\nExample\n\njulia> Ticker(\"JPM\") # Ticker for Chase\nTicker(\"JPM\")\n\njulia> Ticker(Permno(47896), Date(2020))\n\"JPM\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.IbesTicker","page":"Identifier Types","title":"WRDSMerger.IbesTicker","text":"IbesTicker <: SecurityIdentifier\n\nIbesTicker(s::AbstractString)::IbesTicker\n\nIbesTicker(x::AbstractIdentifier, d::Date)::String\n\nIbesTicker is the primary identifier in the IBES universe and typically consists of 1-4 characters.\n\nExample\n\njulia> IbesTicker(\"CHL\") # IbesTicker for Chase\nIbesTicker(\"CHL\")\n\njulia> IbesTicker(Permno(47896), Date(2020))\n\"CHL\"\n\n\n\n\n\n","category":"type"},{"location":"linking_identifiers/#WRDSMerger.SecID","page":"Identifier Types","title":"WRDSMerger.SecID","text":"SecID <: SecurityIdentifier\n\nSecID(x::Real)::SecID\n\nSecID(x::AbstractIdentifier, d::Date)::Int\n\nSecID is the primary identifier within the OptionMetrics database.\n\njulia> SecID(102936) # SecID for Chase\nSecID(102936)\n\njulia> SecID(NCusip(\"46625H10\"), Date(2020))\n102936\n\n\n\n\n\n","category":"type"},{"location":"misc_utilities/#Utilities","page":"Miscellaneous Utilities","title":"Utilities","text":"","category":"section"},{"location":"misc_utilities/#Range-Joins","page":"Miscellaneous Utilities","title":"Range Joins","text":"range_join performs inequality-based joins between DataFrames, useful when matching on date ranges or other interval conditions. Conditions are specified with the Conditions struct.","category":"section"},{"location":"misc_utilities/#Internal-Helpers","page":"Miscellaneous Utilities","title":"Internal Helpers","text":"","category":"section"},{"location":"misc_utilities/#WRDSMerger.Conditions","page":"Miscellaneous Utilities","title":"WRDSMerger.Conditions","text":"Conditions(fun::Function, l::Union{Symbol,String}, r::Union{Symbol,String})\nConditions(l, fun, r)\n\nA condition for use with range_join. Specifies a comparison function fun (e.g., <=, >=) applied between column l from the left DataFrame and column r from the right DataFrame.\n\n\n\n\n\n","category":"type"},{"location":"misc_utilities/#WRDSMerger.range_join","page":"Miscellaneous Utilities","title":"WRDSMerger.range_join","text":"function range_join(\n    df1::DataFrame,\n    df2::DataFrame,\n    on,\n    conditions::Array{Conditions};\n    minimize=nothing,\n    join_conditions::Union{Array{Symbol}, Symbol}=:and,\n    validate::Tuple{Bool, Bool}=(false, false),\n    jointype::Symbol=:inner\n)\n\nJoins the dataframes based on a series of conditions, designed to work with ranges\n\nArguments\n\ndf1::DataFrame: left DataFrame\ndf2::DataFrame: right DataFrame\non: either array of column names or matched pairs\nconditions::Array{Conditions}: array of Conditions, which specifies the function (<=, >, etc.), left and right columns\njointype::Symbol=:inner: type of join, options are :inner, :outer, :left, and :right\nminimize: either nothing or an array of column names or matched pairs, minimization will take place in order\njoin_conditions::Union{Array{Symbol}, Symbol}: defaults to :and, otherwise an array of symbols that is 1 less than the length of conditions that the joins will happen in (:or or :and)\nvalidate::Tuple{Bool, Bool}: Whether to validate, this works differently than the equivalent in DataFrames joins, here, validate insures that a single row from the dataframe is not duplicated. So validate=(true, false) means that there are no duplicated rows from the left dataframe in the result.\n\nExample\n\ndf1 = DataFrame(\n    firm=1:10,\n    date=Date.(2013, 1:10, 1:10)\n)\n\ndf2 = df1[:, :]\ndf2[!, :date_low] = df2.date .- Day(2)\ndf2[!, :date_high] = df2.date .+ Day(2)\nselect!(df2, Not(:date))\n\nrange_join(\n    df1,\n    df2,\n    [:firm],\n    [\n        Conditions(<, :date, :date_high),\n        Conditions(>, :date, :date_low)\n    ],\n    join_conditions=[:and]\n)\n\n\n\n\n\n","category":"function"},{"location":"misc_utilities/#WRDSMerger.check_schema_perms","page":"Miscellaneous Utilities","title":"WRDSMerger.check_schema_perms","text":"check_schema_perms(conn, library::String)\n\nVerify that the user can access a schema\n\n\n\n\n\n","category":"function"},{"location":"misc_utilities/#WRDSMerger.approx_row_count","page":"Miscellaneous Utilities","title":"WRDSMerger.approx_row_count","text":"approx_row_count(conn, library::String, table::String)\n\nGet an approximate count of the number of rows in a table\n\n\n\n\n\n","category":"function"},{"location":"misc_utilities/#WRDSMerger.modify_col!","page":"Miscellaneous Utilities","title":"WRDSMerger.modify_col!","text":"modify_col! tries to identify the real type of a column, especially for strings that are actually dates or floats that are actually integers. Almost all data downloaded from WRDS correctly specifies dates, but all numbers are stored as float8, even items like year which should be an integer. This uses multiple dispatch to check if all elements in a given column are compatible with changing type and then changes the type of the column. Note that for strings this function does not by default try to convert integer like strings to integer (such as GVKey), it only converts strings that look like a date, datetime, or time.\n\n\n\n\n\n","category":"function"},{"location":"#WRDSMerger.jl-Docs","page":"Introduction","title":"WRDSMerger.jl Docs","text":"","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"From the Julia REPL:\n\njulia> ]add WRDSMerger\n\njulia> using Pkg; Pkg.add(WRDSMerger)\n\nFrom source:\n\njulia> ]add https://github.com/junder873/WRDSMerger.jl\n\njulia> using Pkg; Pkg.add(url=\"https://github.com/junder873/WRDSMerger.jl\")","category":"section"},{"location":"#Establish-DB-Connection","page":"Introduction","title":"Establish DB Connection","text":"This package requires a subscription to WRDS and can only access datasets that are included in your subscription. Any database connection that supports DBInterface.execute will work. There are several ways to connect:","category":"section"},{"location":"#LibPQ","page":"Introduction","title":"LibPQ","text":"LibPQ.jl connects directly to the WRDS Postgres server. It has no query length limit, which is important for functions like crsp_data that generate very long queries:\n\nusing LibPQ\nconn = LibPQ.Connection(\n    \"\"\"\n        host = wrds-pgdata.wharton.upenn.edu\n        port = 9737\n        user='username'\n        password='password'\n        sslmode = 'require' dbname = wrds\n    \"\"\"\n)\n\nNote, running the above too many times may cause WRDS to temporarily block your connections for having too many. Run the connection at the start of your script and only rerun that part when necessary.","category":"section"},{"location":"#ODBC","page":"Introduction","title":"ODBC","text":"Alternatively, you can connect to WRDS through an ODBC driver using ODBC.jl. ODBC is considerably faster at converting large result sets to DataFrames but requires additional driver setup. I recommend following the setup steps listed under WRDS support for connecting with Stata (since that also uses ODBC). You can find that information here.\n\nThe third method is if you have the data locally, such as in a DuckDB database or as Parquet/CSV files. DuckDB is the recommended approach for local data (and is what this package uses for testing). DuckDB can read Parquet, CSV, and other file formats directly:\n\nusing DuckDB\nconn = DBInterface.connect(DuckDB.DB, \"my_wrds_data.duckdb\")\n\nIf your DuckDB database uses different schema/table names than the WRDS defaults, update the table mappings:\n\nWRDSMerger.default_tables[\"comp_funda\"] = \"comp.funda\"\nWRDSMerger.default_tables[\"crsp_stocknames\"] = \"crsp.stocknames\"\n# ... etc.\n\nSee Using Local Files with DuckDB for more details on working with local files.","category":"section"},{"location":"#Connection-Method-Comparison","page":"Introduction","title":"Connection Method Comparison","text":"Method Setup Speed Query Length Best For\nLibPQ Pkg.add(\"LibPQ\") only Slower for large results No limit General WRDS access\nODBC Requires driver installation Fast for large DataFrames May have limits Bulk data downloads\nDuckDB Pkg.add(\"DuckDB\") only Very fast (local I/O) No limit Local data / testing\n\nLibPQ requires no setup beyond installation. ODBC is considerably faster at converting large result sets to DataFrames (e.g., downloading the full CRSP daily stockfile takes ~4 minutes with ODBC vs ~24 minutes with LibPQ on a gigabit connection), but requires an ODBC driver to be installed separately. ODBC also stores your password in the driver settings, making it easier to share a project without exposing credentials. DuckDB is only for local data (Parquet, CSV, or DuckDB database files) and cannot connect to the WRDS Postgres server.","category":"section"},{"location":"download_data/#Downloading-WRDS-Data","page":"Downloading WRDS Data","title":"Downloading WRDS Data","text":"This page covers functions for exploring the WRDS database and downloading data from Compustat, CRSP, and Fama-French. All functions take a database connection as the first argument (see Establish DB Connection).\n\nThese functions query WRDS tables whose names are stored in WRDSMerger.default_tables. If your database uses different table names, update the dictionary before calling these functions.","category":"section"},{"location":"download_data/#Explore-WRDS","page":"Downloading WRDS Data","title":"Explore WRDS","text":"These functions help you discover what data is available in WRDS.","category":"section"},{"location":"download_data/#Compustat","page":"Downloading WRDS Data","title":"Compustat","text":"Download fundamental financial data from Compustat. By default downloads annual data; set annual=false for quarterly. Note that column names differ between annual and quarterly datasets (e.g., sale vs saleq).","category":"section"},{"location":"download_data/#CRSP","page":"Downloading WRDS Data","title":"CRSP","text":"Functions for downloading CRSP stock data, market indices, delisting returns, and making common adjustments (split-adjusting prices, incorporating delisting returns, etc.).\n\nTo use monthly data instead of daily, update the default tables:\n\nWRDSMerger.default_tables[\"crsp_stock_data\"] = \"crsp.msf\"\nWRDSMerger.default_tables[\"crsp_index\"] = \"crsp.msi\"\nWRDSMerger.default_tables[\"crsp_delist\"] = \"crsp.msedelist\"","category":"section"},{"location":"download_data/#Fama-French-Factors","page":"Downloading WRDS Data","title":"Fama-French Factors","text":"Download daily Fama-French factor data, including the market, size, value, and momentum factors.","category":"section"},{"location":"download_data/#WRDSMerger.list_libraries","page":"Downloading WRDS Data","title":"WRDSMerger.list_libraries","text":"list_libraries(conn)\n\nLoad the list of Postgres schemata the user has permission to access\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.list_tables","page":"Downloading WRDS Data","title":"WRDSMerger.list_tables","text":"list_tables(conn, library::String)\n\nList all of the views/tables/foreign tables within a schema\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.describe_table","page":"Downloading WRDS Data","title":"WRDSMerger.describe_table","text":"describe_table(conn, library::String, table::String)\n\nGet a table's description (row count, columns, column types)\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.get_table","page":"Downloading WRDS Data","title":"WRDSMerger.get_table","text":"get_table(\n                conn,\n                library::String,\n                table::String;\n                obs::Union{Nothing, Int} = nothing,\n                offset::Int = 0,\n                cols = nothing\n            )\n\nCreate a DataFrame from a table\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.raw_sql","page":"Downloading WRDS Data","title":"WRDSMerger.raw_sql","text":"raw_sql(\n    conn,\n    query::String\n)\n\nExecutes raw sql code, and converts code to a DataFrame\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.comp_data","page":"Downloading WRDS Data","title":"WRDSMerger.comp_data","text":"function comp_data(\n    conn[,\n    gvkeys::AbstractArray{String},]\n    dateStart::Union{Date,Int}=1950,\n    dateEnd::Union{Date,Int}=Dates.today();\n    annual::Bool=true,\n    filters::Dict{String,<:Any}=Dict(\n        \"datafmt\" => \"STD\",\n        \"indfmt\" => \"INDL\",\n        \"consol\" => \"C\",\n        \"popsrc\" => \"D\"\n    ),\n    cols::Array{String}=[\"gvkey\", \"datadate\", \"fyear\", \"sale\", \"revt\", \"xopr\"]\n)\n\nDownloads data from Compustat for firms (if list of gvkeys is provided, filters to those firms) available firms over a period. Data can be annual (set annual=true) or quarterly (set annual=false). For quarterly data, you also likely need to change the columns that are downloaded (ie, sales is \"saleq\" in quarterly data).\n\nFilters is a dictionary of String => String (or array of String) pairings that will be applied to the SQL query.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_stocknames","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_stocknames","text":"function crsp_stocknames(\n    conn;\n    cols::Array{String}=[\"permno\", \"cusip\", \"ncusip\", \"comnam\", \"namedt\", \"nameenddt\", \"ticker\"]\n)\n\nfunction crsp_stocknames(\n    conn,\n    cusip::Array{String};\n    cols::Array{String}=[\"permno\", \"cusip\", \"ncusip\", \"comnam\", \"namedt\", \"nameenddt\", \"ticker\"],\n    cusip_col=\"cusip\", # either \"cusip\" \"ncusip\" or \"ticker\"\n)\n\nfunction crsp_stocknames(\n    conn,\n    permno::Array{<:Number};\n    cols::Array{String}=[\"permno\", \"cusip\", \"ncusip\", \"comnam\", \"namedt\", \"nameenddt\", \"ticker\"],\n)\n\nDownload crsp.stockname data (with non-missing ncusip). If an array of strings is passed, by default assumes it is a list of cusips, can be a list of ncusip or tickers (change cusip_col). Can also take an array of numbers which is assumed to be a list of permnos.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_market","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_market","text":"function crsp_market(\n    conn,\n    dateStart::Union{Date,Int}=1950,\n    dateEnd::Union{Date,Int}=Dates.today();\n    col::Union{String, Array{String}}=\"vwretd\"\n)\n\nDownloads the data from the daily or monthly stock index file (dsi and msi) for a range of dates with one value for each day (with various return columns). Available columns are:\n\n\"vwretd\": Value weighted return with dividends\n\"vwretx\": Value weighted return without dividends\n\"ewretd\": Equal weighted return with dividends\n\"ewretx\": Equal weighted return without dividends\n\"sprtrn\": S&P500 return\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_data","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_data","text":"function crsp_data(\n    conn,\n    [permnos::Vector{<:Real},]\n    s::Date=Date(1925),\n    e::Date=today();\n    cols = [\"ret\", \"vol\", \"shrout\"],\n    filters::Dict{String, <:Any}=Dict{String, Any}(),\n    adjust_crsp_data::Bool=true\n)\n\nfunction crsp_data(\n    conn,\n    permnos::Vector{<:Real},\n    dates::Vector{Date},\n    [dates_end::Vector{Date}];\n    cols=[\"ret\", \"vol\", \"shrout\"],\n    adjust_crsp_data::Bool=true,\n    query_size_limit::Int=3000\n)\n\nDownloads data from the crsp stockfiles, which are individual stocks. To download the data from the monthly stockfile, change the default table to the monthly stockfile:\n\nWRDSMerger.default_tables[\"crsp_stock_data\"] = \"crsp.msf\"\nWRDSMerger.default_tables[\"crsp_index\"] = \"crsp.msi\"\nWRDSMerger.default_tables[\"crsp_delist\"] = \"crsp.msedelist\"\n\nArguments\n\npermnos::Vecotr{<:Real}: A vector of firm IDs, if provided, will only download data for those firms\ns::Date=Date(1925) and e::Date=today(): Downloads all data between two dates provided\ndates::Vector{Date}: Downloads data for a set of permnos on the date provided\ndates_end::Vector{Date}: If provided, then treats the dates as the start of a period and will download data for the permnos between the two dates\nadjust_crsp_data::Bool=true: This will call crsp_adjust with all options   set to true, it will only do the operations that it has the data for.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_delist","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_delist","text":"function crsp_delist(\n    conn;\n    cols::Array{String}=[\n        \"permno\",\n        \"dlstdt\",\n        \"dlret\"\n    ],\n    date_start::Date=Date(1926),\n    date_end::Date=today()\n)\n\nFetches the CRSP delist dataset, typically for the returns on the day of delisting.\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.crsp_adjust","page":"Downloading WRDS Data","title":"WRDSMerger.crsp_adjust","text":"function crsp_adjust(\n    conn,\n    df::DataFrame;\n    kwargs...\n)\n\nThis makes 4 common adjustments to CRSP data:\n\nWhen the price in CRSP is negative, that means there was not a specific close price. Typically, researchers take the absolute value to get the actual price.\nPrices are not adjusted for splits (returns are). CRSP includes the number (cfascpr) that will adjust prices to be comparable through time\nSimilar to prices, shares outstanding are not adjusted. The number used to adjust is different due to various events.\nPrices are not adjusted for delisting, so this downloads the necessary dataset and adjusts returns accordingly.\n\nArguments\n\nOptions on what to adjust\n\nadjustprcnegatives::Bool=true: Corresponds to (1) above\nadjustprcsplits::Bool=true: Corresponds to (2) above\nadjustshrsplits::Bool=true: Corresponds to (3) above\nadjust_delist::Bool=true: Corresponds to (4) above\n\nPre-existing column names\n\ndate::String=\"date\": date column\nidcol::String=\"permno\": primary identifier (permno) column\nprc_col::String=\"prc\": price column\nret_col::String=\"ret\": return column\nprcsplitscol::String=\"cfacpr\": price split adjustment factor\nshrout_col::String=\"shrout\": shares outstanding\nshroutsplitscol::String=\"cfacshr\": share split adjustment factor\n\nOptions to relabel columns\n\nadjustednegprc_col::String=\"prc\": relabel prices to this after taking absolute value\nadjustedprccol::String=\"prc_adj\": relabel prices to this after adjusting for splits\nadjustedshroutcol::String=\"shrout_adj\":relabel shares outstanding to this after adjusting for splits\n\n\n\n\n\n","category":"function"},{"location":"download_data/#WRDSMerger.ff_data","page":"Downloading WRDS Data","title":"WRDSMerger.ff_data","text":"ff_data(conn, date_start=Date(1926,7,1), date_end=today(); cols=[\"date\",\"mktrf\",\"smb\",\"hml\",\"rf\",\"umd\"])\n\nDownload Fama-French factor data from the ff.factors_daily table (configurable via default_tables[\"ff_factors\"]). Returns a DataFrame with the requested columns over the given date range.\n\nAvailable columns include mktrf, smb, hml, rf, and umd (momentum).\n\n\n\n\n\n","category":"function"},{"location":"default_behavior/#Default-Behavior","page":"Default Behavior","title":"Default Behavior","text":"This package has some defaults that are important to be aware of during use.","category":"section"},{"location":"default_behavior/#Different-Return-Types","page":"Default Behavior","title":"Different Return Types","text":"The general design principle in Julia is that if a type is a function name, it should return that type. In this package, this is not always the case. When an AbstractIdentifier uses an external type (e.g. Int), it will return that AbstractIdentifier. However, when an AbstractIdentifier is used on another AbstractIdentifier, it will most often return the underlying value. For example:\n\nPermno(47896) # returns the type Permno\nPermno(Permco(20436), Date(2020)) # an Int type\n\nThe reason for this difference is that the AbstractIdentifier types are primarily meant for internal use and communicating information to the functions, but it is more often necessary to have the common Julia type for later joins. If it is needed to have the AbstractIdentifier, then run:\n\nWRDSMerger.convert_identifier(Permno, Permco(20436), Date(2020))","category":"section"},{"location":"default_behavior/#Default-Options-in-Conversions","page":"Default Behavior","title":"Default Options in Conversions","text":"","category":"section"},{"location":"default_behavior/#Parent-Firms","page":"Default Behavior","title":"Parent Firms","text":"Certain SecurityIdentifiers have a direct link to a parent firm, most obviously NCusip and HdrCusip (with NCusip6 and HdrCusip6). These are type aliases for the parameterized Cusip{HistCode} and Cusip6{HistCode} types (e.g., NCusip = Cusip{:historical}, HdrCusip = Cusip{:current}). In certain situations, it can make sense to allow a match to occur through these parent firms, such as when the end goal is to match a SecurityIdentifier to a FirmIdentifier.\n\nFor example, consider the case of NCusip(\"46625H21\"), which is not in the data. Therefore, when trying to convert this to another SecurityIdentifier, it will return missing since there is not an exact match:\n\nPermno(NCusip(\"46625H21\"), Date(2020))\n\nHowever, if trying to match this NCusip to a FirmIdentifier, then it will return a match:\n\nPermco(NCusip(\"46625H21\"), Date(2020))\n\nThis is because while the NCusip is not in the data, the NCusip6(\"46625H\") is:\n\nPermco(NCusip6(\"46625H\"), Date(2020))\n\nThe logic here is that it should not matter if a particular security does not match to a firm if the parent firm of that security does match to a firm. This is very useful if the integrity of the Cusip values is in question. This behavior can be disabled or enabled by setting allow_parent_firm;\n\nPermno(NCusip(\"46625H21\"), Date(2020); allow_parent_firm=true)\nPermco(NCusip(\"46625H21\"), Date(2020); allow_parent_firm=false)","category":"section"},{"location":"default_behavior/#Outside-of-Date-Ranges-and-Singular-Matches","page":"Default Behavior","title":"Outside of Date Ranges and Singular Matches","text":"Many links are supposed to be only valid for a specific date range. For example, linking NCusip(\"16161A10\") to Permno(47896) is only valid between 1996-04-01 to 2001-01-01. However, this NCusip only ever links to that Permno, so the default behavior in this package is to provide that match:\n\nPermno(NCusip(\"16161A10\"), Date(2020)) # outside date range\n\nIf the link does not only provide one potential result (e.g., if that NCusip also could go to a different Permno), then this will return missing. The default behavior can be disabled by setting allow_inexact_date=false:\n\nPermno(NCusip(\"16161A10\"), Date(2020); allow_inexact_date=false) # outside date range","category":"section"},{"location":"default_behavior/#Supremacy-of-Permno","page":"Default Behavior","title":"Supremacy of Permno","text":"In WRDS, Permnos are one of the easiest items to link. For example, there are easily accessible tables for linking GVKey <-> Permno, IbesTicker <-> Permno, and NCusip <-> Permno. This makes it very useful for most links. Therefore, when this package is determining the best path for linking two identifiers that are not directly linked (e.g., RPEntity <-> GVKey), this package will default to using Permno even if other paths exist of equal length.\n\nFor example, by default, this package links RPEntity to NCusip6. NCusip6 has direct links to both Permno and Permco, both of which directly link to GVKey. The default in this package will choose the path that goes through Permno (RPentity -> NCusip6 -> Permno -> GVKey).\n\nnote: Note\nIf there is a shorter path, then it will still choose that (e.g., SecID -> NCusip -> NCusip6 -> RPEntity instead of SecID -> NCusip -> Permno -> NCusip6 -> RPEntity).","category":"section"}]
}
